<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File 
*************************************************	         
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="8.8.2.202303221145" AlpVersion="8.7.7">
<Model>
	<Id>1665787765893</Id>
	<Name><![CDATA[AnyLogic Jsonifier Library]]></Name>
	<Description><![CDATA[A simple library for enabling AnyLogic objects to be JSON serializable. 
After creating an instance of it, use the provided "toJson" and "fromJson" functions.
It also includes a filter for some customization into what is included when calling "toJson".]]></Description>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[anylogic_jsonifier_library]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Second]]></ModelTimeUnit>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1665787765899</Id>
			<Name><![CDATA[ALJsonifier]]></Name>
			<AdditionalClassCode><![CDATA[{
// initialize the filter here to allow for functionality when this obj is created without a constructor / as a POJO;
// this will get overridden if being created as an agent.
jsonFilter = new JsonFilter(objmapper, true);
}

/**
* Initialize the class when called within an AL scope (e.g., as a variable object).
* @param anyAgent An agent that is already registered with the AL Engine; can be the Java keyword 'this' if calling this constructor from an agent.
*/
public ALJsonifier(Agent anyAgent) {
	// TODO not sure if this is needed (check what functionality is lost from just using the empty constructor).
	this.createAndStart(anyAgent);
}

private enum ObjectAgentType {
	JAVA, // pure java type
	AGENT_SINGLE, // single agent
	AGENT_POPULATION, // anylogic-population (of agents)
	AGENT_COLLECTION // java collection with agent-typed components
}]]></AdditionalClassCode>
			<Import><![CDATA[import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Modifier;
import java.util.stream.IntStream;
import java.lang.reflect.Field;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.File;
import java.util.Scanner;
import java.io.FileReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.InvalidPathException;
import com.fasterxml.jackson.databind.module.SimpleModule;
import java.lang.reflect.Type;
import java.util.stream.Collectors;]]></Import>
			<StartupCode><![CDATA[// Initialize the filter based on the parameter values
if (!isCustomConfiguration) { 
	// start empty with default autogenerated setting
	jsonFilter = new JsonFilter(objmapper, isBlacklistMode, 
						isBlacklistMode ? JsonFilter.defaultBlacklistAutogeneratedSetting : JsonFilter.defaultWhitelistAutogeneratedSetting, 
						null, null, null);
} else if (isBlacklistMode) {
	// use the BL params
	jsonFilter = new JsonFilter(
						objmapper, isBlacklistMode, 
						includeAutogeneratedsBL,
						includedPackagesBL,
						includedClassesBL,
						includedNamesBL
	);
} else {
	// use the WL params
	jsonFilter = new JsonFilter(
						objmapper, isBlacklistMode, 
						includeAutogeneratedsWL,
						includedPackagesWL,
						includedClassesWL,
						includedNamesWL
	);
}

// This next step is purely for library validation purposes across future updates.
// It confirms the "Default value" used by the parameters match the constants defined in the JsonFilter class.
// Setting it up this way lets users see which objects are included by default 
//		w/o needing to waste runs for printing the queried defaults or needing to reference the docs.
if (_includeAutogeneratedsBL_DefaultValue_xjal() != JsonFilter.defaultBlacklistAutogeneratedSetting)
	warning("Parameter for blacklisted autogenerated setting is not synced properly; library needs to be fixed");
	
if (_includeAutogeneratedsWL_DefaultValue_xjal() != JsonFilter.defaultWhitelistAutogeneratedSetting)
	warning("Parameter for whitelisted autogenerated setting is not synced properly; library needs to be fixed");

if (!Set.of(_includedPackagesBL_DefaultValue_xjal()).equals(JsonFilter.defaultBlacklistedPackages))
	warning("Parameter for blacklisted packages are not synced properly; library needs to be fixed");

if (!Set.of(_includedPackagesWL_DefaultValue_xjal()).equals(JsonFilter.defaultWhitelistedPackages))
	warning("Parameter for whitelisted packages are not synced properly; library needs to be fixed");

if (!Set.of(_includedClassesBL_DefaultValue_xjal()).equals(JsonFilter.defaultBlacklistedClasses))
	warning("Parameter for blacklisted classes are not synced properly; library needs to be fixed");

if (!Set.of(_includedClassesWL_DefaultValue_xjal()).equals(JsonFilter.defaultWhitelistedClasses))
	warning("Parameter for whitelisted classes are not synced properly; library needs to be fixed");

if (!Set.of(_includedNamesBL_DefaultValue_xjal()).equals(JsonFilter.defaultBlacklistedNames))
	warning("Parameter for blacklisted names are not synced properly; library needs to be fixed");

if (!Set.of(_includedNamesWL_DefaultValue_xjal()).equals(JsonFilter.defaultWhitelistedNames))
	warning("Parameter for whitelisted names are not synced properly; library needs to be fixed");
]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1665787765897</Id>
				<Name><![CDATA[1665787765897]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>false</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>false</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1665820800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1665787765895</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1665787765898</CurrentLevel>
			<ConnectionsId>1665787765894</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1665787820200</Id>
					<Name><![CDATA[objmapper]]></Name>
					<Description><![CDATA[An instance of Jackson's <code>ObjectMapper</code> class; used in the <code>toJson</code> and <code>fromJson</code> functions.]]></Description>
					<X>70</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="true">
						<Type><![CDATA[ObjectMapper]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[createMapper()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1665787820202</Id>
					<Name><![CDATA[jsonFilter]]></Name>
					<X>70</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="true">
						<Type><![CDATA[JsonFilter]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[// initialized in addtl class code]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441114532</Id>
					<Name><![CDATA[isBlacklistMode]]></Name>
					<Description><![CDATA[Whether the filter is in blacklist mode (included objects are omitted from the output) or whitelist mode (only included objects will be in the output).
Calling this parameter's `set_` function will apply the mode and then reset based on the included objects in the other parameters.]]></Description>
					<X>-250</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[jsonFilter.setMode(isBlacklistMode, false)
			.includeGenerated(isBlacklistMode ? includeAutogeneratedsBL : includeAutogeneratedsWL)
			.includePackages(isBlacklistMode ? includedPackagesBL : includedPackagesWL)
			.includeClasses(isBlacklistMode ? includedClassesBL : includedClassesWL)
			.includeNames(isBlacklistMode ? includedNamesBL : includedNamesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441114530</Id>
							<Label><![CDATA[Filter mode]]></Label>
							<EditorContolType>RADIO_BUTTONS</EditorContolType>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[Blacklist]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[Whitelist]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</PredefParamValue>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATE_SECTION</DelimeterType>
							<StartSection><![CDATA[To-JSON Settings]]></StartSection>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441170868</Id>
					<Name><![CDATA[isCustomConfiguration]]></Name>
					<Description><![CDATA[Whether to start the filter with empty inclusions or filled with the sets of objects. If empty, being in blacklist mode will try to output everything, while being in whitelist mode will block everything.
Calling this function's `set_` function and with the custom option enabled (i.e., `true`) will use the values of the parameters; if the empty option is enabled (i.e., `false`) the autogenerated flag will use the blacklist's parameter value and the sets will be cleared.]]></Description>
					<X>-250</X><Y>60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isCustomConfiguration) {
	jsonFilter
			.includeGenerated(isBlacklistMode ? includeAutogeneratedsBL : includeAutogeneratedsWL)
			.includePackages(isBlacklistMode ? includedPackagesBL : includedPackagesWL)
			.includeClasses(isBlacklistMode ? includedClassesBL : includedClassesWL)
			.includeNames(isBlacklistMode ? includedNamesBL : includedNamesWL);
} else {
	jsonFilter
			.includeGenerated(isBlacklistMode ? includeAutogeneratedsBL : includeAutogeneratedsWL)
			.clearPackages()
			.clearClasses()
			.clearNames();
}]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441170866</Id>
							<Label><![CDATA[Initial configuration]]></Label>
							<EditorContolType>RADIO_BUTTONS</EditorContolType>
							<PredefParamValue>
								<Id>1682441170865</Id>
								<Name><![CDATA[Empty]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>1682441170864</Id>
								<Name><![CDATA[Custom]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</PredefParamValue>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441255593</Id>
					<Name><![CDATA[includeAutogeneratedsBL]]></Name>
					<Description><![CDATA[Whether the autogenerated objects will be initially included in the blacklist (i.e., omitted from any JSON outputs).
Calling this function's `set_` function will update the filter, or you can use the function inside the filter object. 
An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.includeGenerated(includeAutogeneratedsBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441255591</Id>
							<Label><![CDATA[Block autogenerated objects]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441621807</Id>
					<Name><![CDATA[includeAutogeneratedsWL]]></Name>
					<Description><![CDATA[Whether the autogenerated objects will be initially included in the whitelist (i.e., included in  any JSON outputs).
Calling this function's `set_` function will update the filter, or you can use the function inside the filter object. 
An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.includeGenerated(includeAutogeneratedsWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441621805</Id>
							<Label><![CDATA[Allow autogenerated objects]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>1682441621804</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441417778</Id>
					<Name><![CDATA[includedPackagesBL]]></Name>
					<Description><![CDATA[The initial set of package names, for which any classes belonging to these will be blocked from being outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {
	"com.anylogic.libraries.pypeline",
	"anylogic_jsonifier_library",
	"com.anylogic.libraries.processmodeling",
	"com.anylogic.libraries.material_handling",
	"com.anylogic.libraries.pedestrian",
	"com.anylogic.libraries.rail",
	"com.anylogic.libraries.road",
	"com.anylogic.libraries.fluid",
	"com.anylogic.engine.markup",
	"com.anylogic.engine.connectivity",
	"com.anylogic.engine.presentation"
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.clearPackages().includePackages(includedPackagesBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441417776</Id>
							<Label><![CDATA[Blocked packages]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441478227</Id>
					<Name><![CDATA[includedPackagesWL]]></Name>
					<Description><![CDATA[The initial set of package names, for which any classes belonging to these will be allowed to be outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {
	"java.util",
	"java.lang"
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.clearPackages().includePackages(includedPackagesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441478225</Id>
							<Label><![CDATA[Allowed packages]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441320254</Id>
					<Name><![CDATA[includedClassesBL]]></Name>
					<Description><![CDATA[The set of classes initially blocked being outputted to JSON. 
Calling this function's `set_` function will update the filter. An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Class<?>[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new Class<?>[] {
	Color.class,
	Font.class,
	Shape.class,
	EventOriginator.class,
	IStatechartState.class,
	AbstractLinkToAgent.class,
	Scale.class,
	CustomDistribution.class,
	Random.class,
	Histogram.Appearance.class,
	Histogram2D.Appearance.class,
	Chart2DPlot.Appearance.class,
	SDIntegrationManager.class,
	LinkToAgentAnimationSettings.class,
	Port.class
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.clearClasses().includeClasses(includedClassesBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441320252</Id>
							<Label><![CDATA[Blocked classes]]></Label>
							<EditorContolType>ELEMENT_CHOOSER</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441393197</Id>
					<Name><![CDATA[includedClassesWL]]></Name>
					<Description><![CDATA[The set of classes allowed to be outputted to JSON.
Calling this function's `set_` function will update the filter. An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Class<?>[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new Class<?>[] {
	Number.class,
	Boolean.class,
	Agent.class,
	AgentList.class,
	ChartItem.class,
	DataItem.class,
	DataSet.class,
	HistogramData.class,
	StatisticsContinuous.class,
	StatisticsDiscrete.class
}	]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.clearClasses().includeClasses(includedClassesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441393195</Id>
							<Label><![CDATA[Allowed classes]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441493523</Id>
					<Name><![CDATA[includedNamesBL]]></Name>
					<Description><![CDATA[The initial set of object names, or regex patterns, for which any object whose name matches any one of these will be blocked from being outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {
	".+_xjal",
	"serialVersionUID"
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.clearNames().includeNames(includedNamesBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441493521</Id>
							<Label><![CDATA[Blocked names]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441516127</Id>
					<Name><![CDATA[includedNamesWL]]></Name>
					<Description><![CDATA[The initial set of object names, or regex patterns, for which any object whose name matches any one of these will be allowed to be outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {

}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.clearNames().includeNames(includedNamesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441516125</Id>
							<Label><![CDATA[Allowed names]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1665787820172</Id>
					<Name><![CDATA[warnedParameters]]></Name>
					<X>480</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="true">
						<CollectionClass><![CDATA[LinkedHashSet]]></CollectionClass>
						<ElementClass><![CDATA[String]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1678491140331</Id>
					<Name><![CDATA[serializedClasses]]></Name>
					<X>230</X><Y>520</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="true">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[Class<?>]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
						<CollectionInitializer Class="CodeValue">
							<Code><![CDATA[Arrays.stream(Serializers.class.getDeclaredClasses())
        .filter(innerClass -> innerClass != Serializers.MyStdSerializer.class)
        .map(innerClass -> {
            ParameterizedType parameterizedType = (ParameterizedType) innerClass.getGenericSuperclass();
            return (Class<?>) parameterizedType.getActualTypeArguments()[0];
        })
        .collect(Collectors.toList())]]></Code>
						</CollectionInitializer>
					</Properties>

				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1665787820174</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON.<br>
Note that agents and agent populations are handled manually due to a recursive issue.<br>
@param object Any data type that can be converted to JSON<br>
@return The JSON form of the given object, or `null` if an error was encountered<br>]]></Description>
					<X>250</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[return toJson(object, false);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1665787820176</Id>
					<Name><![CDATA[fromJson]]></Name>
					<Description><![CDATA[Converts a JSON string to a POJO (i.e., not an AnyLogic-based class - namely agent or agent population types)<br>
@param json A JSON string to be converted **or** a path to a file with this information<br>
@param clazz The class - specifically a standard Java type - to convert the provided string to<br>
@return The object of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>500</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return fromJson(json, null, clazz);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[HashMap<String, Object>]]></ReturnType>
					<Id>1665787820180</Id>
					<Name><![CDATA[agentToMap]]></Name>
					<Description><![CDATA[Extracts all public fields from the given agent and puts it into a varname-to-varvalue map. ]]></Description>
					<X>230</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeNullFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[seenAgents]]></Name>
						<Type><![CDATA[HashSet<Object>]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Converting agent '%s' of type: %s", agent.getName(), agent.getClass());
if (seenAgents == null) seenAgents = new HashSet<Object>();

// field mapping, name to value
HashMap<String, Object> map = new HashMap<>();

// store index if part of population (individual agents will have index of -1)
//	(using internal prefixes ["_"], to not confuse w/any potential user vars of the same name)
if (agent.getIndex() >= 0) {
	// new: dont add index if part of default population
	if (agent.getPopulation() != null && !agent.getDefaultPopulation().equals(agent.getPopulation()))
		map.put("_index", agent.getIndex());
}

// generic agents should return immediately
if (agent.getClass().equals(Agent.class)) {
	return map;
}

// for custom agent types, use reflection to get all fields inside of agent
Field[] fields = agent.getClass().getFields();
String name;
Object value;
for (Field field : fields) {
	name = field.getName();
	
	//traceln("Examining field named '%s' (type: %s)...", name, field.getType());
	//traceln("  -> %s - %s", field.getType().getPackageName(), field.getType().getSimpleName());
	
	// skip known internal or problematic fields
	//	(e.g., for the scale, connections, internal datasets, etc.)
	// also skip common classes with assumed insignificance (e.g., shapes)
	if (jsonFilter.skipJsonifying(field.getName(), field.getModifiers(), field.getType())) {
		//traceln("\tSkipping!");
		continue;
	}
	
	// skip for constants/enums
	if (Modifier.isStatic(field.getModifiers())) {
		//traceln("\tSkipping!");
		continue;
	}
	
	// skip for agent populations with types that hshould be filtered
	//if (value instanceof AgentArrayList)
		
	try {
		field.trySetAccessible(); 
		value = field.get(agent);
		//traceln("\tValue is of type: %s", value.getClass());
		if (value == null) {
			//traceln("\tSkipping!");
		}
		// skip if value is top-level agent
		else if (value.equals(agent.getRootAgent())) {
			//traceln("\tSkipping!");
			continue;
		}
		// apply this agent func for single agents
		else if (value instanceof Agent) {
			// skip if already seen
			if (seenAgents.contains(value)) {
				//traceln("\tSkipping!");
				continue;
			}
			//traceln("\t%s IS AGENT; CONVERTING TO MAP!", name);
			seenAgents.add((Agent)value); // XXX - Added to resolve stackoverflow when using toJson with no filters
			value = agentToMap((Agent)value, includeNullFields, seenAgents);
		}
		// apply other agent func for populations 
		else if (value instanceof AgentArrayList) {
			// skip if already seen
			if (seenAgents.contains(value)) {
				//traceln("\tSkipping!");
				continue;
			}
			//traceln("\t%s IS AGENTPOP; CONVERTING TO LIST!", name);
			
			value = agentPopToList((AgentArrayList)value, includeNullFields, seenAgents);
		}
		// handle when value is a collection/map holding an incompatible AnyLogic type
		else if (value instanceof Collection || value instanceof Map) {
			boolean skip = false;
			//traceln("\tCollection named '%s', of type %s", name, value.getClass());
			for (java.lang.reflect.Type type : ((ParameterizedType)field.getGenericType()).getActualTypeArguments()) {
				//traceln("\t\tType named: %s of class %s", type.getTypeName(), type.getClass());
				try {
				
					if (jsonFilter.skipJsonifying( (Class)type )) {
						skip = true;
						break;
					}
					
				} catch (ClassCastException e) {
					skip = true;
					break;
				}
			}
			if (skip) {
				//traceln("\tSkipping!");
				continue;
			}
		}
		//traceln("\t%s: %s", name, value.getClass());
		map.put(name, value);
	} catch (IllegalAccessException e) {
		//traceln("\terrorred!!!!!");
		if (includeNullFields) {
			map.put(name, null);
		}
	}
}

//traceln(":: summary of types ::");
//map.forEach((k,v) -> traceln("'%s' -> %s (from: %s)", k, v.getClass().getSimpleName(), v.getClass().getPackageName()));
//traceln(":: ................ ::");
/*
try {
	traceln(agent);
	String s = objmapper.writeValueAsString(map);
	traceln("%s\n\n", s);
} catch (Exception e) {e.printStackTrace();}
*/

return map;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ObjectAgentType]]></ReturnType>
					<Id>1665787820182</Id>
					<Name><![CDATA[agentType]]></Name>
					<Description><![CDATA[Classifies an object based on its underlying class and how it serialization needs to happen.]]></Description>
					<X>230</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentObj]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[// if we've registered serializers, can just return as a normal java object
if (serializedClasses.stream().anyMatch(cls -> cls.isAssignableFrom(agentObj.getClass())))
	return ObjectAgentType.JAVA;

// TODO does type-3 return as expected? might need to use getComponentType/instanceof
if (agentObj instanceof Agent)
	return ObjectAgentType.AGENT_SINGLE;
else if (agentObj instanceof AgentArrayList)
	return ObjectAgentType.AGENT_POPULATION;
else if (agentObj instanceof Collection 
	&& ((Collection)agentObj).size() > 0)
	return ObjectAgentType.AGENT_COLLECTION;
return ObjectAgentType.JAVA;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList<HashMap<String, Object>>]]></ReturnType>
					<Id>1665787820184</Id>
					<Name><![CDATA[agentPopToList]]></Name>
					<Description><![CDATA[Creates a list of Map objects, one for each converted agent in the population]]></Description>
					<X>230</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentPop]]></Name>
						<Type><![CDATA[AgentArrayList<Agent>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeNullFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[seenAgents]]></Name>
						<Type><![CDATA[HashSet<Object>]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Converting pop of size %s, type: %s", agentPop.size(), agentPop.getClass());
//traceln("=> %s", jsonFilter.skipJsonifying(agentPop.get(0).getClass()));
if (seenAgents == null) seenAgents = new HashSet<Object>();

// convert each individual agent in the population into a hashmap
ArrayList<HashMap<String, Object>> popList = new ArrayList<>();
// first check for filter
if (agentPop.size() > 0 && jsonFilter.skipJsonifying(agentPop.get(0).getClass())) {
	return popList;
}

for (Agent a : agentPop) {
	if (!seenAgents.contains(a)) {
		seenAgents.add(a);
		popList.add( agentToMap(a, includeNullFields, seenAgents) );
	}
};
return popList;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1665787820186</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON.<br>
Note that agents and agent populations are handled manually due to a recursive issue.<br>
@param object Any data type that can be converted to JSON<br>
@param prettyprint Whether to output JSON in "pretty" format (with newlines, tabs, etc.)<br>
@return The JSON form of the given object, or `null` if an error was encountered<br>]]></Description>
					<X>230</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[prettyprint]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Body><![CDATA[String output = null;
try {
	output = prettyprint
				? objmapper.writerWithDefaultPrettyPrinter().writeValueAsString(object)
				: objmapper.writeValueAsString(object);
} catch (JsonProcessingException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList]]></ReturnType>
					<Id>1665787820190</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON (an array of objects mapping parameter names to value) to an arraylist of agents.<br>
@param json A JSON string **or** a path to a file with this information<br>
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly<br>
@param agent_clazz The class of the AL agent type<br>
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return AgentArrayList An access-only ArrayList of the agents]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>480</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")

// handle whether input is a JSON string or path to JSON file
json = parseJsonString(json);

try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Get at specific pointer if it was provided
	if (pointer != null && !pointer.isEmpty())
		root = root.at(pointer);
	// Build the output array based on the number of agent jsons detected
	ArrayList<T> newPop = new ArrayList();
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		T childAgent = fromAgentJson(childJson, agent_clazz, anyAgent);
		newPop.add(childAgent);
	}
	return newPop;
} catch (Exception e) {
	e.printStackTrace();
}

return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1665787820192</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent<br>
The agent will be added to the specified population.<br>
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information<br>
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@param population The population to add this agent to
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>480</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// handle whether input is a JSON string or path to JSON file
json = parseJsonString(json);

// Convert json to hashmap for name/value lookup
HashMap<String, Object> paramLookup = fromJson(json, pointer, HashMap.class);

// Agent is "generic" when not alive/started
boolean genericAgent = population == null;

try {
	T myAgent;
	if (genericAgent) {
		myAgent = clazz
				.getDeclaredConstructor()
				.newInstance();
	} else {
		myAgent = clazz
					.getDeclaredConstructor(Engine.class, Agent.class, AgentList.class)
					.newInstance(population.getOwner().getEngine(), population.getOwner(), population);
		population._add(myAgent);
	}
	
	// User may have only passed a subset of parameters,
	//	so try to set them all to defaults first.
	// Note: cannot always call this because will throw null exception when default values 
	//	reference function that require non-static usage (e.g., random functions)
	try {
		myAgent.setParametersToDefaultValues();
	} catch (NullPointerException e) {
		// At least mark as set
		myAgent.markParametersAreSet();
	}
	
	paramLookup.forEach( (name,value) -> {
		// don't include custom key added to agent json in `agentPopToList`
		if (!name.equals("_index")) {
			boolean result;
			try {
				result = myAgent.setParameter(name, value, false);
			} catch (ClassCastException e) {
				// assume value is a string referring to a named object in the root agent
				Object adjustedValue = getObjectOfName(value.toString(), myAgent.getRootAgent());
				result = myAgent.setParameter(name, adjustedValue, false);
			}
			// alert user, but only once per run
			if (!result && !warnedParameters.contains(name)) {
				traceln("ONE-TIME WARNING: Parameter '%s' not found! Options: %s", name, Arrays.toString(myAgent.getParameterNames()));
				warnedParameters.add(name);
			}
		}
	});
	
	// Create and start if "living" agent
	if (!genericAgent) {
		int index = population.size();
		population.callCreate(myAgent, index);
		myAgent.start();
	}
	
	return myAgent;
} catch (InvocationTargetException | InstantiationException | NoSuchMethodException | IllegalAccessException e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1665787820194</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[Converts a list of agents from JSON (specifically an array of objects mapping parameter names to value) and adds it to an existing population.<br>
@param json A valid JSON array **or** a path to a file with this information<br>
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly<br>
@param agent_clazz The Java class for the agent type to convert to<br>
@param population The population to add the agents to]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>480</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")

// handle whether input is a JSON string or path to JSON file
json = parseJsonString(json);

try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Get at specific pointer if it was provided
	if (pointer != null && !pointer.isEmpty())
		root = root.at(pointer);
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		fromAgentJson(childJson, agent_clazz, population);
	}
} catch (Exception e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1665787820198</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent.<br>
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>500</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[return ALJsonifier.fromAgentJson(json, null, clazz, anyAgent);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Object]]></ReturnType>
					<Id>1673381927099</Id>
					<Name><![CDATA[getObjectOfName]]></Name>
					<Description><![CDATA[Use reflection to retrieve the named object from inside of the given agent.<br>
If errors are encountered, they'll be printed out and null will be returned.]]></Description>
					<X>480</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[name]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// note: called by 'fromAgentJson'

Object obj = null;
try {
	obj = agent.getClass().getField(name).get(agent);
} catch (Exception e) {
	e.printStackTrace();
}
return obj;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1678298911650</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active agent, initialized from the root level agent.<br>
This function will only work if called from the AnyLogic editor with the ALJsonifier object created as an agent itself (i.e., not programmatically) or manually initialized by calling its `createAndStart` function.<br>
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public <T extends Agent>]]></CustomModifierCode>                 	
					<X>520</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return ALJsonifier.fromAgentJson(json, clazz, getRootAgent());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1678300792532</Id>
					<Name><![CDATA[writeFile]]></Name>
					<Description><![CDATA[Write some content to a file.<br>
If the file already exists, content will be overridden.<br>
Any errors will be printed to the console.]]></Description>
					<X>230</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[content]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try {
	FileWriter myWriter = new FileWriter(file);
	myWriter.write(content);
	myWriter.close();
} catch (IOException e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678301012847</Id>
					<Name><![CDATA[readFile]]></Name>
					<Description><![CDATA[Read and return some content from file.<br>
If the file is not found, the error will be printed to the console and null will be returned.]]></Description>
					<X>480</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[String output = null;
try {
	StringBuilder builder = new StringBuilder();
	File myObj = new File(file);
	Scanner myReader = new Scanner(myObj);
	while (myReader.hasNextLine()) {
		builder.append(myReader.nextLine());
	}
	myReader.close();
	output = builder.toString();
} catch (FileNotFoundException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678309101105</Id>
					<Name><![CDATA[parseJsonString]]></Name>
					<Description><![CDATA[Allows passing a ".json" file to be read and return, otherwise returns the input.]]></Description>
					<X>480</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[input]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[input = input.strip();
if (input.startsWith("{") || input.startsWith("[")) {
	// assume JSON string
	return input;
}

try {
	// test to make sure is a valid path
	java.nio.file.Path p = Paths.get(input);
	if (!p.toFile().exists()) {
		throw new RuntimeException(String.format("Detected input as a file but it does not exist: %s", input));
	}
	// it is! read and return it
	return readFile(input);
} catch (InvalidPathException ex) {
	// not a valid path; assume JSON string to be returned
    return input;
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678310009514</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON and write it to the given file (will overwrite it if it exists) without pretty printing.<br>
Note that agents and agent populations are handled manually due to a recursive issue.<br>
@param object Any data type that can be converted to JSON<br>
@param file The path to the desried JSON output file; can be relative to the working directory]]></Description>
					<X>270</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[toJson(object, false, file);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678310051457</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON and write it to a file (it will overwrite if it exists).<br>
Note that agents and agent populations are handled manually due to a recursive issue.<br>
@param object Any data type that can be converted to JSON<br>
@param prettyprint Whether to output JSON in "pretty" format (with newlines, tabs, etc.)<br>
@param file The path to the desried JSON output file; can be relative to the working directory]]></Description>
					<X>250</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[prettyprint]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[String output = toJson(object, prettyprint);
writeFile(file, output);]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ObjectMapper]]></ReturnType>
					<Id>1678394507287</Id>
					<Name><![CDATA[createMapper]]></Name>
					<X>90</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[ObjectMapper mapper = new ObjectMapper().configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);
mapper.addMixInAnnotations(Event.class, SharedSuppressionMixIn.class); // TODO change to more generic parent type?
mapper.addMixInAnnotations(Port.class, PortSuppressionMixIn.class);

SimpleModule module = new SimpleModule();
module.addSerializer(DataSet.class, new Serializers.DataSetSerializer());
module.addSerializer(HistogramData.class, new Serializers.Histogram1DSerializer());
module.addSerializer(Histogram2DData.class, new Serializers.Histogram2DSerializer());
module.addSerializer(StatisticsDiscrete.class, new Serializers.StatisticsDiscreteSerializer());
module.addSerializer(StatisticsContinuous.class, new Serializers.StatisticsContinuousSerializer());
module.addSerializer(Statechart.class, new Serializers.StatechartSerializer());
module.addSerializer(FlowchartBlock.class, new Serializers.FlowchartBlockSerializer());
module.addSerializer(Agent.class, new Serializers.AgentSerializer());
module.addSerializer(AgentList.class, new Serializers.AgentListSerializer());
mapper.registerModule(module);
return mapper;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678400422725</Id>
					<Name><![CDATA[toString]]></Name>
					<X>70</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return jsonFilter.toString();]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1682542721746</Id>
					<Name><![CDATA[fromJson]]></Name>
					<Description><![CDATA[Converts a JSON string to a POJO (i.e., not an AnyLogic-based class - namely agent or agent population types)<br>
@param json A JSON string to be converted **or** a path to a file with this information<br>
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly<br>
@param clazz The class - specifically a standard Java type - to convert the provided string to<br>
@return The object of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>480</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[// handle whether input is a JSON string or path to JSON file
json = parseJsonString(json);

T output = null;

// Agent related conversion require specialize functions
if (Agent.class.isAssignableFrom(clazz) || AgentList.class.isAssignableFrom(clazz)) {
	try {
		throw new Exception("Need to use `fromPopulationJson` for converting agent populations (returning null)");
	} catch (Exception e) {e.printStackTrace();}
	return null;
}
	
try {
	JsonNode root = objmapper.readTree(json);
	JsonNode target = pointer == null || pointer.isEmpty() ? root : root.at(pointer);
	output = objmapper.treeToValue(target, clazz);
} catch (IOException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1682543731263</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent.<br>
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information<br>
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>480</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// handle whether input is a JSON string or path to JSON file
json = parseJsonString(json);

// Don't let the user try to avoid passing an active agent
if (anyAgent == null || anyAgent.getEngine() == null) {
	throw new RuntimeException(String.format("Argument 'anyAgent' must be a valid, active Agent ... was given '%s' (engine = %s)", anyAgent, anyAgent==null?null:anyAgent.getEngine()));
}

// Convert json (at pointer) to hashmap for name/value lookup
HashMap<String, Object> paramLookup = fromJson(json, pointer, HashMap.class);

try {
	T myAgent = clazz
			.getDeclaredConstructor()
			.newInstance();
	
	// User may have only passed a subset of parameters,
	//	so try to set them all to defaults first.
	// Note: cannot always call this because will throw null exception when default values 
	//	reference function that require non-static usage (e.g., random functions)
	try {
		myAgent.setParametersToDefaultValues();
	} catch (NullPointerException e) {
		// At least mark as set
		myAgent.markParametersAreSet();
	}
	
	paramLookup.forEach( (name,value) -> {
		// don't include custom key added to agent json in `agentPopToList`
		if (!name.equals("_index")) {
			boolean result = myAgent.setParameter(name, value, false);
			// alert user, but only once per run
			if (!result && !warnedParameters.contains(name)) {
				traceln("ONE-TIME WARNING: Parameter " + name + " not found!");
				warnedParameters.add(name);
			}
		}
	});

	// fully initialize the agent / "awaken" it
	myAgent.createAndStart(anyAgent);
	
	return myAgent;
} catch (InvocationTargetException | InstantiationException | NoSuchMethodException | IllegalAccessException e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1682543917517</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent<br>
The agent will be added to the specified population.<br>
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information<br>
@param clazz The class of the AL agent type to convert the provided string to<br>
@param population The population to add this agent to
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>500</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[return ALJsonifier.fromAgentJson(json, null, clazz, population);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList]]></ReturnType>
					<Id>1682543923418</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON (an array of objects mapping parameter names to value) to an arraylist of agents.<br>
@param json A JSON string **or** a path to a file with this information<br>
@param agent_clazz The class of the AL agent type<br>
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return AgentArrayList An access-only ArrayList of the agents]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>500</X><Y>260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[return ALJsonifier.fromPopulationJson(json, null, agent_clazz, anyAgent);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1682543925517</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[Converts a list of agents from JSON (specifically an array of objects mapping parameter names to value) and adds it to an existing population.
@param json A valid JSON array **or** a path to a file with this information
@param agent_clazz The Java class for the agent type to convert to
@param population The population to add the agents to]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>500</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[ALJsonifier.fromPopulationJson(json, null, agent_clazz, population);]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1665787765894</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1665787765898</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Image>
					<Id>1665791283971</Id>
					<Name><![CDATA[image]]></Name>
					<X>-8</X><Y>-8</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[return true;]]></OnClickCode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Width>16</Width>
					<Height>16</Height>
					<Rotation>0.0</Rotation>
					<ImageFiles>
						<ImageResourceReference>
							<PackageName><![CDATA[anylogic_jsonifier_library]]></PackageName>
							<ClassName><![CDATA[jsonifier_16.png]]></ClassName>
						</ImageResourceReference>
					</ImageFiles>
					<OriginalSize>false</OriginalSize>
				</Image>
				<Text>
					<Id>1678300425032</Id>
					<Name><![CDATA[text1]]></Name>
					<X>220</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[To-JSON variants
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300473785</Id>
					<Name><![CDATA[text2]]></Name>
					<X>470</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[From-JSON variants
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300488541</Id>
					<Name><![CDATA[text3]]></Name>
					<X>210</X><Y>370</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[To-JSON helpers]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300495277</Id>
					<Name><![CDATA[text4]]></Name>
					<X>470</X><Y>370</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[From-JSON helpers]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300553340</Id>
					<Name><![CDATA[text5]]></Name>
					<X>50</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Shared objects]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
	</ActiveObjectClasses>	
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Frame>
		<Width>1000</Width>
		<Height>600</Height>
	</Frame>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ShutdownCompact>false</ShutdownCompact>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
		</ExportSettings>
	</Database>
	
	<RunConfiguration ActiveObjectClassId="1665787765899">
		<Id>1665787765903</Id>
		<Name><![CDATA[RunConfiguration]]></Name>
		<MaximumMemory>512</MaximumMemory>
		<ModelTimeProperties>
			<StopOption><![CDATA[Stop at specified time]]></StopOption>
			<InitialDate><![CDATA[1665705600000]]></InitialDate>	
			<InitialTime><![CDATA[0.0]]></InitialTime>	
			<FinalDate><![CDATA[1668384000000]]></FinalDate>	
			<FinalTime><![CDATA[100.0]]></FinalTime>	
		</ModelTimeProperties>
		<AnimationProperties>
			<StopNever>true</StopNever>
			<ExecutionMode>realTimeScaled</ExecutionMode>
			<RealTimeScale>1.0</RealTimeScale>
			<EnableZoomAndPanning>true</EnableZoomAndPanning>
			<EnableDeveloperPanel>false</EnableDeveloperPanel>
			<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
		</AnimationProperties>
		<Inputs>		
		</Inputs>
		<Outputs>
		</Outputs>
	</RunConfiguration>
	<Experiments>	
		<!--   =========   Simulation Experiment   ========  -->
		<SimulationExperiment ActiveObjectClassId="1665787765899">
			<Id>1665787765901</Id>
			<Name><![CDATA[Simulation]]></Name>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<MaximumMemory>512</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<SeedValue>1</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>

			<Presentation>
				<Text>
					<Id>1665787765902</Id>
					<Name><![CDATA[text]]></Name>
					<X>50</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[JSONifier for AnyLogic]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

			<Parameters>			
				<Parameter>
					<ParameterName><![CDATA[isBlacklistMode]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[isCustomConfiguration]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includeAutogeneratedsBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includeAutogeneratedsWL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedPackagesBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedPackagesWL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedClassesBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedClassesWL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedNamesBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedNamesWL]]></ParameterName>
				</Parameter>
			</Parameters>			
			<PresentationProperties>
				<EnableZoomAndPanning>true</EnableZoomAndPanning>
				<ExecutionMode><![CDATA[realTimeScaled]]></ExecutionMode>
				<Title><![CDATA[JSONifier for AnyLogic : Simulation]]></Title>	
				<EnableDeveloperPanel>true</EnableDeveloperPanel>
				<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
				<RealTimeScale>1.0</RealTimeScale>
			</PresentationProperties>
			<ModelTimeProperties>
				<StopOption><![CDATA[Never]]></StopOption>
				<InitialDate><![CDATA[1665705600000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1668384000000]]></FinalDate>	
				<FinalTime><![CDATA[100.0]]></FinalTime>	
			</ModelTimeProperties>
			<BypassInitialScreen>true</BypassInitialScreen>
		</SimulationExperiment>	
	</Experiments>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1665787875730</Id>
			<Name><![CDATA[CustomAnnotationIntrospector]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;

import com.fasterxml.jackson.databind.introspect.Annotated;
import com.fasterxml.jackson.databind.type.TypeFactory;

import com.fasterxml.jackson.databind.introspect.AnnotatedMember;



/**
 * CustomAnnotationIntrospector
 */	
public class CustomAnnotationIntrospector extends JacksonAnnotationIntrospector implements Serializable {

	private final JsonFilter filter;

    /**
     * Default constructor
     */
    public CustomAnnotationIntrospector() {
    	filter = null;
    }

    /**
     * Constructor initializing the fields
     */
    public CustomAnnotationIntrospector(JsonFilter filter) {
		this.filter = filter;
    }
    
    @Override
    public boolean hasIgnoreMarker(AnnotatedMember a) {
    	if (super.hasIgnoreMarker(a))
    		return true;
    	if (filter == null)
    		return false;
    	return a.getAnnotation(AnyLogicInternalCodegenAPI.class) != null;
    }
    
    @Override
    protected boolean _isIgnorable(Annotated a) {
    	if (super._isIgnorable(a))
    		return true;
    	if (filter == null)
    		return false;
    	return filter.skipJsonifying(a.getRawType());
    }

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1665787888479</Id>
			<Name><![CDATA[JsonFilter]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;
import com.fasterxml.jackson.databind.introspect.Annotated;
import com.fasterxml.jackson.databind.type.TypeFactory;
import java.lang.reflect.Modifier;
import java.lang.reflect.Field;


/**
 * A custom filter used when converting Java/AnyLogic objects to JSON.
 * It can also work in a blacklist mode (default) or a whitelist mode:
 * 	In blacklist mode, **including** an object to it will **exclude** it from the output.
 * 	In whitelist mode, it will prevent all objects from outputted **except** for what's included in the filter.
 * There are three possible ways to reference object - by class, package, or name.
 * 	Both modes operate based on an 'OR' condition, meaning you only have to specify one way and it will be applied.
 */	
public class JsonFilter {
	private ObjectMapper parent;
	
	/**
	 * A reference for whether whether autogenerated objects are included when in **blacklist** mode.
	 */
	public final static boolean defaultBlacklistAutogeneratedSetting = true;
	
	/**
	 * A reference for what classes are included in this class's usage of "default classes" when in **blacklist** mode.
	 */
	public final static HashSet<Class<?>> defaultBlacklistedClasses = new HashSet<>(Arrays.asList(
			Color.class,
			Font.class,
			Shape.class,
			EventOriginator.class,
			IStatechartState.class,
			AbstractLinkToAgent.class,
			Scale.class,
			CustomDistribution.class,
			Random.class,
			Histogram.Appearance.class,
			Histogram2D.Appearance.class,
			Chart2DPlot.Appearance.class,
			SDIntegrationManager.class,
			LinkToAgentAnimationSettings.class,
			Port.class
			));
	
	/**
	 * A reference for what packages are included in this class's usage of "default packages" when in **blacklist** mode.
	 */
	public final static HashSet<String> defaultBlacklistedPackages = new HashSet<>(Arrays.asList(
		"com.anylogic.libraries.pypeline",
		"anylogic_jsonifier_library",
		"com.anylogic.libraries.processmodeling",
		"com.anylogic.libraries.material_handling",
		"com.anylogic.libraries.pedestrian",
		"com.anylogic.libraries.rail",
		"com.anylogic.libraries.road",
		"com.anylogic.libraries.fluid",
		"com.anylogic.engine.markup",
		"com.anylogic.engine.connectivity",
		"com.anylogic.engine.presentation"
		));
	
	/**
	 * A reference for what packages are included in this class's usage of "default names" when in **blacklist** mode.
	 */
	public final static HashSet<String> defaultBlacklistedNames = new HashSet<>(Arrays.asList(
			".+_xjal",
			"serialVersionUID"
		));
	
	/**
	 * A reference for whether whether autogenerated objects are included when in **whitelist** mode.
	 */
	public final static boolean defaultWhitelistAutogeneratedSetting = false;
	
	/**
	 * A reference for what classes are included in this class's usage of "default classes" when in **whitelist** mode.
	 */
	public final static HashSet<Class<?>> defaultWhitelistedClasses = new HashSet<>(Arrays.asList(
			Number.class,
			Boolean.class,
			Agent.class,
			AgentList.class,
			ChartItem.class,
			DataItem.class,
			DataSet.class,
			HistogramData.class,
			StatisticsContinuous.class,
			StatisticsDiscrete.class
			));
	
	/**
	 * A reference for what packages are included in this class's usage of "default packages" when in **whitelist** mode.
	 */
	public final static HashSet<String> defaultWhitelistedPackages = new HashSet<>(Arrays.asList(
			"java.util",
			"java.lang"
			
		));
	
	/**
	 * A reference for what packages are included in this class's usage of "default names" when in **whitelist** mode.
	 */
	public final static HashSet<String> defaultWhitelistedNames = new HashSet<>(Arrays.asList(
			
		));
	
	
	/**
	 * The active set of classes to consider in JSON-conversion.
	 */
	private HashSet<Class<?>> includedClasses = new HashSet<>();
	
	/**
	 * The active set of packages for which classes directly in the package are considered in JSON-conversion.
	 */
	private HashSet<String> includedPackages = new HashSet<>();
	
	/**
	 * The active set of object names (parsed as regex patterns) to consider in JSON-conversion.
	 */
	private HashSet<String> includedNames = new HashSet<>();
	
	/**
	 * Whether to include autogenerated objects
	 */
	private boolean includeGeneratedObjects = false;
	
	/**
	 * Whether the filtering is operating in blacklist mode (included => won't be outputted) or whitelist mode (included => only will be outputted)
	 */
	private boolean inBlacklistMode = true;
	
	
	/**
	 * Create a new filter object in blacklist mode with the default set of names/classes/packages.
	 */
	public JsonFilter(ObjectMapper parentMapper) {
		// TODO should throw an error if parent mapper is null?
		this(parentMapper, true);
	}
	
	/**
	 * Create a new filter object in blacklist mode.
	 * @param parentMapper A reference to the object mapper this filter should apply to
	 * @param loadDefault Whether to load the default set of classes + packages
	 */
	public JsonFilter(ObjectMapper parentMapper, boolean loadDefault) {
		this(parentMapper, true, loadDefault);
	}
	
	/**
	 * Create a new filter object.
	 * @param parentMapper A reference to the object mapper this filter should apply to
	 * @param inBlacklistMode Whether to set the filter in blacklist mode (vs whitelist mode)
	 * @param loadDefault Whether to load the default set of classes + packages
	 */
	public JsonFilter(ObjectMapper parentMapper, boolean inBlacklistMode, boolean loadDefault) {
		this.parent = parentMapper;
		this.inBlacklistMode = inBlacklistMode;
		this.includeGeneratedObjects = inBlacklistMode ? defaultBlacklistAutogeneratedSetting : defaultWhitelistAutogeneratedSetting;
		if (loadDefault) {
			resetNames();
			resetClasses();
			resetPackages();
		}
	}
	
	/**
	 * Create a new filter object with specific initial values
	 * @param parentMapper A reference to the object mapper this filter should apply to
	 * @param inBlacklistMode Whether to set the filter in blacklist mode (vs whitelist mode)
	 * @param includeAutogenerateds Whether autogenerated objects are included in the filter
	 * @param includedPackages The list of packages to initially have included; if null, will start with a cleared set
	 * @param includedClasses The list of classes to initially have included; if null, will start with a cleared set
	 * @param includedNames The list of names to initially have included; if null, will start with a cleared set
	 */
	public JsonFilter(ObjectMapper parentMapper, boolean inBlacklistMode, boolean includeAutogenerateds, String[] includedPackages, Class<?>[] includedClasses, String[] includedNames) {
		this.parent = parentMapper;
		this.inBlacklistMode = inBlacklistMode;
		this.includeGeneratedObjects = includeAutogenerateds;
		if (includedPackages == null)
			clearPackages();
		else
			includePackages(includedPackages);
		
		if (includedClasses == null)
			clearClasses();
		else
			includeClasses(includedClasses);
		
		if (includedNames == null)
			clearNames();
		else
			includeNames(includedNames);
	}
	
	/**
	 * Determine if the given info seems to be an autogenerated object.
	 * Both arguments are optional (may be null)
	 * @param name
	 * @param clazz
	 * @return
	 */
	private static boolean looksGenerated(String name, int modifiers, Class<?> clazz) {
		// [notes]
		// _ds_* == only datasets
		// *_xjal == can be HyperArrays, Level[], Agent types, SDIntegrationManager, Map, EventTimeout; sometimes protected and static
		// __* == seem to be all protected and static, but any types (even common like double)
		// _* = protected static ints
		// any vars with the @AnyLogicInternalCodegenAPI annotation -- BUT DOESNT HAVE RETENTION SO IS ERASED ON RUNTIME
		// _origin_VA
		
		if (name != null) {
			// if class is not provided, assume all _ds_* names are generated
			if (name.startsWith("_ds_") && (clazz == null || DataSet.class.isAssignableFrom(clazz))) {
				return true;
			}
	
			// no class info is considered, as it can be too many types
		    if (name.endsWith("_xjal")) {
		    	return true;
		    }
		    
		    // fixed name of autogen'd view area (even though it likely can't/won't be serialized)
		    if (name.equals("_origin_VA")) {
		    	return true;
		    }
		}
		
		if (clazz != null) {
		    // check for _* or __* objects that are protected and static 
		    if (name != null && name.startsWith("_") && Modifier.isProtected(modifiers) && Modifier.isStatic(modifiers)) {
		    	return true;
		    }
		}
		
	    return false;
	}
	
	/**
	 * Determines whether a field should be omitted from being converted to JSON, based on info about it.
	 * To qualify based on the name is based on regex pattern matching.
	 * To qualify for being "inside" the package, the exact class must be inside the package.
	 * To qualify for being a class, the class must be assignable from the one in the filter
	 * 		(i.e., it can either be the same class as the one in the filter or a child class of it).
	 * 
	 * @param name The name of the object; null=skipped
	 * @param modifiers The object modifiers; 1=skipped/just public
	 * @param clazz The class of the object; null=skipped
	 * @return true if the provided field should not be included in the outputted JSON
	 */
	public boolean skipJsonifying(String name, int modifiers, Class<?> clazz) {
		boolean skip = false; // store in a variable since generated-checked should be applied first, and possibly overridden by the following checks
		if (looksGenerated(name, modifiers, clazz)) {
			// skip when (included and blacklist) or (not included and not blacklist/whitelist)
			skip = inBlacklistMode == includeGeneratedObjects;
		}
		
		// for blacklist mode, can immediate consider it skippable if ANY of the conditions are met
		boolean nameIncluded = name != null && includedNames.stream().anyMatch(n -> name.matches(n));
		if (inBlacklistMode && nameIncluded) {
			skip = true;
		}
		boolean clsIncluded = clazz != null && includedClasses.stream().anyMatch(c -> c.isAssignableFrom(clazz));
		if (inBlacklistMode && clsIncluded) {
			skip = true;
		}
		boolean pkgIncluded = clazz != null && includedPackages.contains(clazz.getPackageName());
		if (inBlacklistMode && pkgIncluded) {
			skip = true;
		}
		
		// for whitelist mode, ALL the conditions need to fail to be skipped
		if (!inBlacklistMode && !nameIncluded && !clsIncluded && !pkgIncluded) {
			skip = true;
		}
		
		// otherwise, assume it should be OK to include
		return skip;
	}
	
	/**
	 * Determines whether a field should be omitted from being converted to JSON, based on just an object's name.
	 * To qualify based on the name is based on regex pattern matching.
	 * @param name The name of the object; assumed to be non-null
	 * @return true if the provided field should not be included in the outputted JSON
	 */
	public boolean skipJsonifying(String name) {
		return skipJsonifying(name, 1, null);
	}
	
	/**
	 * Determines whether a field should be omitted from being converted to JSON, based on the object's class and package name.
	 * To qualify for being a class, the class must be assignable from the one in the filter
	 * 		(i.e., it can either be the same class as the one in the filter or a child class of it).
	 * To qualify for being "inside" the package, the exact class must be inside the package.
	 * @param clazz The class of the object; assumed to be non-null
	 * @return true if the provided field should not be included in the outputted JSON
	 */
	public boolean skipJsonifying(Class<?> clazz) {
		return skipJsonifying(null, 1, clazz);
	}
	
	/**
	 * Get a report of everything that will/won't be skipped in the given object.
	 * @param obj
	 * @return
	 */
	public Map<Pair<String,Class<?>>,Boolean> skipJsonifyingReport(Object obj) {
		Map<Pair<String,Class<?>>,Boolean> report = new HashMap<>();
		for (Field f : obj.getClass().getDeclaredFields()) {
			String name = f.getName();
			Class<?> cls = f.getType();
			report.put(new Pair<>(name, cls), skipJsonifying(name, f.getModifiers(), cls));
		}
		return report;
	}
	
	/**
	 * Gets the packages whose packages are included in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * @return a copy of the set of fully qualified package names
	 */
	public HashSet<String> getIncludedPackages() {
		return new HashSet<>(includedPackages);
	}
	
	/**
	 * Gets the classes that are included in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Any subclasses will also be included (e.g., if `Shape.class` is included, `ShapeCAD.class` will be considered included as well).
	 * @return a copy of the set of classes
	 */
	public HashSet<Class<?>> getIncludedClasses() {
		return new HashSet<>(includedClasses);
	}
	
	/**
	 * Gets the name patterns who are included in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * @return a copy of the set of names, as regex patterns
	 */
	public HashSet<String> getIncludedNames() {
		return new HashSet<>(includedNames);
	}
	
	/**
	 * Various objects are auto-generated and added to your model by AnyLogic in response to certain user-defined objects/properties.
	 * See `setGeneratedInclusion` for an example.
	 * 
	 * @return Whether auto-generated objects are included in the outputted JSON
	 */
	public boolean isGeneratedIncluded() {
		return this.includeGeneratedObjects;
	}
	
	/**
	 * 
	 * @return Whether the filter is currently in blacklist mode (no objects except those included will be outputted)
	 */
	public boolean isInBlacklistMode() {
		return this.inBlacklistMode;
	}
	
	/**
	 * @return Whether the filter is currently in whitelist mode (only included objects will be outputted)
	 */
	public boolean isInWhitelistMode() {
		return !this.inBlacklistMode;
	}
	
	/**
	 * Update the mode of this object (i.e., blacklist or whitelist).
	 * If the mode is being toggled, the previous classes/names/packages will be cleared and defaults for the new mode loaded in, otherwise nothing will happen.
	 * @param inBlacklist Whether to set the filter to be in blacklist mode (vs in whitelist)
	 * @return a reference to this object
	 */
	public JsonFilter setMode(boolean inBlacklist) {
		return setMode(inBlacklist, true);
	}
	
	/**
	 * Update the mode of this object (i.e., blacklist or whitelist).
	 * Nothing will be changed if attempting to set it in the mode it's already in.
	 * @param inBlacklist Whether to set the filter to be in blacklist mode (vs in whitelist)
	 * @param loadDefault Whether to reset classes/names/packages to their default (vs just clear)
	 * @return a reference to this object
	 */
	public JsonFilter setMode(boolean inBlacklist, boolean loadDefault) {
		// do nothing if setting in the already existing mode
		if (this.inBlacklistMode == inBlacklist) 
			return this;

		this.inBlacklistMode = inBlacklist;
		if (loadDefault) {
			return resetClasses().resetNames().resetPackages();
		} else  {
			return clearClasses().clearNames().clearPackages();
		}
	}
	
	
	/**
	 * Various objects are auto-generated and added to your model by AnyLogic in response to certain user-defined objects/properties.
	 * For example, adding a Plot object with 3 lines set to the 'Value' type (i.e., not referencing a defined dataset)
	 * 		will autogenerate 3 DataSets with the name structure `_X_expressionN_dataSet_xjal`,
	 * 		where 'X' is the name of the plot and N is a number between 0 and 2 (for each of the 3 lines).
	 * This method lets you set whether you want to include those objects in the filter.
	 * Setting this to false will do its best to ensure only user-added objects are in the outputted JSON.
	 * 		Specifically, it will exclude any objects suffixed with "_xjal".
	 * Calling this function with the same value multiple times will have no extra effect.
	 * 
	 * @param include Whether to include generated objects
	 * @return a reference to this object
	 */
	public JsonFilter includeGenerated(boolean include) {
		includeGeneratedObjects = include;
		return this.update();
	}
	
	
	/**
	 * Includes the provided package(s) in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * Note: subpackages are not considered.
	 * @param pkgs One or more fully qualified package name
	 * @return a reference to this object
	 */
	public JsonFilter includePackages(String... pkgs) {
		for (String pkg : pkgs)
			includedPackages.add(pkg);
		return this.update();
	}
	
	/**
	 * Includes the provided classes(s) in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param classes One or more classes
	 * @return a reference to this object
	 */
	public JsonFilter includeClasses(Class<?>... classes) {
		for (Class<?> cls : classes)
			includedClasses.add(cls);
		return this.update();
	}
	
	/**
	 * Includes the provided names in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param names One or more regex patterns
	 * @return a reference to this object
	 */
	public JsonFilter includeNames(String... names) {
		for (String name : names)
			includedNames.add(name);
		return this.update();
	}
	
	/**
	 * Excludes the provided package(s) from the filter.
	 * When in blacklist mode (default), these will be allowed in the JSON conversion; in whitelist mode, these will be prevented.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param pkgs One or more fully qualified package name
	 * @return a reference to this object
	 */
	public JsonFilter excludePackages(String... pkgs) {
		for (String pkg : pkgs)
			includedPackages.remove(pkg);
		return this.update();
	}
	
	/**
	 * Excludes the provided classes(s) in the filter.
	 * When in blacklist mode (default), these will be allowed in the JSON conversion; in whitelist mode, these will be prevented.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param classes One or more classes
	 * @return a reference to this object
	 */
	public JsonFilter excludeClasses(Class<?>... classes) {
		for (Class<?> cls : classes)
			includedClasses.remove(cls);
		return this.update();
	}
	
	/**
	 * Excludes the provided names(s) from the filter.
	 * When in blacklist mode (default), these will be allowed in the JSON conversion; in whitelist mode, these will be prevented.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param names One or more regex patterns
	 * @return a reference to this object
	 */
	public JsonFilter excludeNames(String... names) {
		for (String name : names)
			includedNames.remove(name);
		return this.update();
	}
	
	/**
	 * Removes all packages from the current filter.
	 * When in blacklist mode (default), this will allow ALL packages; in whitelist mode, this will prevent ALL packages.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearPackages() {
		includedPackages.clear();
		return this.update();
	}
	
	/**
	 * Removes all classes from the current filter (allowing all classes).
	 * When in blacklist mode (default), this will allow ALL classes; in whitelist mode, this will prevent ALL classes.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearClasses() {
		includedClasses.clear();
		return this.update();
	}
	
	/**
	 * Removes all names from the current filter (allowing any names).
	 * When in blacklist mode (default), this will allow ALL names; in whitelist mode, this will prevent ALL names.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearNames() {
		includedNames.clear();
		return this.update();
	}
	
	/**
	 * Resets the set of packages, reverting to the default set.
	 * @return a reference to this object
	 */
	public JsonFilter resetPackages() {
		clearPackages();
		if (inBlacklistMode) {
			for (String p : defaultBlacklistedPackages)
				includedPackages.add(p);
		} else {
			for (String p : defaultWhitelistedPackages)
				includedPackages.add(p);
		}
		return this.update();
	}
	
	/**
	 * Resets the set of classes, reverting to the default set.
	 * @return a reference to this object
	 */
	public JsonFilter resetClasses() {
		clearClasses();
		if (inBlacklistMode) {
			for (Class<?> c : defaultBlacklistedClasses)
				includedClasses.add(c);
		} else {
			for (Class<?> c : defaultWhitelistedClasses)
				includedClasses.add(c);
		}
		return this.update();
	}
	
	/**
	 * Resets the set of names, reverted to the default set.
	 * @return a reference to this object
	 */
	public JsonFilter resetNames() {
		clearNames();
		if (inBlacklistMode) {
			for (String n : defaultBlacklistedNames)
				includedNames.add(n);
		} else {
			for (String n : defaultWhitelistedNames)
				includedNames.add(n);
		}
		return this.update();
	}
	
	private JsonFilter update() {
		// TODO - do you need to create a new one each time?
		// TODO - confirm this works as expected
		parent.setAnnotationIntrospector(new CustomAnnotationIntrospector(this));
		return this;
	}
	

	@Override
	public String toString() {
		return String.format("JsonFilter[%s | %s autogen, %s names, %s classes, %s packages]", inBlacklistMode ? "BLACK": "WHITE", includeGeneratedObjects ? "YES":"NO", includedNames.size(), includedClasses.size(), includedPackages.size());
	}

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1678394437727</Id>
			<Name><![CDATA[Serializers]]></Name>
			<Text><![CDATA[import java.io.IOException;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.SerializerProvider;
import java.util.stream.IntStream;
import java.util.stream.Collectors;
import java.util.regex.Pattern;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Modifier;

public class Serializers {
	public static class MyStdSerializer<T> extends StdSerializer<T> {
		public MyStdSerializer() {
			this(null);
		}
		
		public MyStdSerializer(Class<T> t) {
			super(t);
		}
		
		@Override
		public void serialize(T value, JsonGenerator jgen, SerializerProvider provider)  
				throws IOException, JsonProcessingException {
			throw new IOException("Need to be called from a child class.");
		}
	}
	
	public static class DataSetSerializer extends MyStdSerializer<DataSet> {

	    @Override
	    public void serialize(
	      DataSet value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        jgen.writeNumberField("xmin", value.getXMin());
	        jgen.writeNumberField("xmean", value.getXMean());
	        jgen.writeNumberField("xmedian", value.getXMedian());
	        jgen.writeNumberField("xmax", value.getXMax());
	        jgen.writeNumberField("ymin", value.getYMin());
	        jgen.writeNumberField("ymean", value.getYMean());
	        jgen.writeNumberField("ymedian", value.getYMedian());
	        jgen.writeNumberField("ymax", value.getYMax());
	        // need to recreate entire plain data table, as the default serializer cuts off with a certain limit. 
	        // i.e., without this, it would look like: "plainDataTable" : [ [ 0.0, 5.0 ], [ 1.0, 5.0 ], [ 2.0, 5.0 ], ..., [ 999.0, 4.0 ], [ "... 1361 more items" ]
	        List<double[]> values = new ArrayList<>();
	    	IntStream.range(0, value.size()).forEach(i -> values.add(new double[]{value.getX(i), value.getY(i)}));
	        jgen.writeObjectField("plainDataTable", value.getPlainDataTable());
	        jgen.writeEndObject();
	    }
	}
	
	public static class Histogram1DSerializer extends MyStdSerializer<HistogramData> {
	    @Override
	    public void serialize(
	    		HistogramData value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        int count = value.count();
	        jgen.writeNumberField("count", count);
	        // Follow similar structure as in ALCloud: User can derive ranges based on min X and interval width
	        jgen.writeNumberField("lowerBound", value.getXMin());
	        jgen.writeNumberField("intervalWidth", value.getIntervalWidth());
	        int[] hits = IntStream.range(0, value.getNumberOfIntervals())
	        		.map(i -> Math.round((float)value.getPDF(i)*count)).toArray();
	        jgen.writeObjectField("hits", hits);
	        // HSimpleData = User set explicit min/max. There may be data outside this range, so add counts of lower/upper range of interval
	        if (value instanceof HistogramSimpleData) {
	        	HistogramSimpleData hdataSimple = (HistogramSimpleData) value;
	        	jgen.writeNumberField("hitsOutLow", Math.round((float)hdataSimple.getPDFOutsideLow()*count));
	        	jgen.writeNumberField("hitsOutHigh", Math.round((float)hdataSimple.getPDFOutsideHigh()*count));
	        }
	        // Add in other useful stats available from histogram
	        HashMap<String, Double> dtableStats = new HashMap<>();
	        dtableStats.put("min", value.min());
	        dtableStats.put("max", value.max());
	        dtableStats.put("mean", value.mean());
	        dtableStats.put("deviation", value.deviation());
	        jgen.writeObjectField("statistics", dtableStats);
	        jgen.writeEndObject();
	    }
	}
	
	public static class Histogram2DSerializer extends MyStdSerializer<Histogram2DData> {
	    @Override
	    public void serialize(
	    		Histogram2DData value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        // Follow similar structure as in ALCloud; user can derive interval size, etc. from available data
	        int nX = value.getNumberOfXIntervals();
	        int nY = value.getNumberOfYIntervals();
	        int[][] hits = new int[nY][nX];
	        int[] hitsOutLow = new int[nX];
	        int[] hitsOutHigh = new int[nX];
	        for (int x = 0; x < nX; x++) {
	        	int xcount = value.count(x);
	        	hitsOutLow[x] = Math.round((float)value.getPDFOutsideLow(x)*xcount);
	        	hitsOutHigh[x] = Math.round((float)value.getPDFOutsideHigh(x)*xcount);
	        	for (int y = 0; y < nY; y++) {
	        		hits[y][x] = Math.round((float)value.getPDF(x, y)*xcount);
	        	}
	        }
	        jgen.writeObjectField("hits", hits);
	        jgen.writeObjectField("hitsOutLow", hitsOutLow);
	        jgen.writeObjectField("hitsOutHigh", hitsOutHigh);
	        jgen.writeNumberField("xMin", value.getXMin());
	        jgen.writeNumberField("xMax", value.getXMax());
	        jgen.writeNumberField("yMin", value.getYMin());
	        jgen.writeNumberField("yMax", value.getYMax());
	        jgen.writeEndObject();
	    }
	}
	
	public static class StatisticsDiscreteSerializer extends MyStdSerializer<StatisticsDiscrete> {
	    @Override
	    public void serialize(
	    		StatisticsDiscrete value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        String[] statRows = value.toString().split("\n");
	    	Arrays.stream(statRows)
	    		.map(s -> s.strip().split("\t"))
	    		.forEach(s -> {try {
	    			jgen.writeNumberField(s[0], Double.valueOf(s[1].replaceAll(",", "")));
	    		} catch (IOException e) {}});
	        jgen.writeEndObject();
	    }
	}
	
	public static class StatisticsContinuousSerializer extends MyStdSerializer<StatisticsContinuous> {
	    @Override
	    public void serialize(
	    		StatisticsContinuous value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        String[] statRows = value.toString().split("\n");
	    	Arrays.stream(statRows)
	    		.map(s -> s.strip().split("\t"))
	    		.forEach(s -> {try {
	    			jgen.writeNumberField(s[0], Double.valueOf(s[1].replaceAll(",", "")));
	    		} catch (IOException e) {}});
	        jgen.writeEndObject();
	    }
	}
	
	public static class StatechartSerializer extends MyStdSerializer<Statechart> {
	    @Override
	    public void serialize(
	    		Statechart value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        jgen.writeObjectField("active_state", Map.of("full", value.getFullState(), "simple", value.getActiveSimpleState().name()));
	        jgen.writeEndObject();
	    }
	}
	
	public static class FlowchartBlockSerializer extends MyStdSerializer<FlowchartBlock> {
		@Override
	    public void serialize(
	    		FlowchartBlock value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			// idky but some block's type are inner classes, so are shown as "<user_model_package>.<AgentType>$<number>" (e.g., mymodel.Main$1)
			// 	and in these cases, the simple name is empty...
			// The toString of built-in blocks seem to reliably have the type in the toString, so use that in these cases.	
	        jgen.writeStringField("type", value.getClass().getSimpleName().isEmpty()
							? Pattern.compile("[^:]+:\\s*(.*?)\\s.+", Pattern.DOTALL).matcher(value.toString()).replaceFirst("$1")
							: value.getClass().getSimpleName());
	        jgen.writeObjectField("parameters",
	        		// wonky collection is to allow non-null values
	        		Arrays.stream(value.getParameterNames()).collect(HashMap::new, (map,name)->map.put(name, value.getParameter(name)), HashMap::putAll)
	        );
	        jgen.writeObjectField("ports",
	        		// xjal check in filter omits internal ports used in messaging
	        		Arrays.stream(value.getClass().getFields()).filter(f -> !f.getName().endsWith("_xjal") && f.getType().isAssignableFrom(FlowchartMappedPort.class))
		        	.collect(
			        		Collectors.toMap(f -> f.getName(), f -> {try { return ((FlowchartMappedPort)f.get(value)).count(); } catch (Exception e) {return -1;}})
			        		)
	        );
	        jgen.writeEndObject();
	    }
	}
	
	public static class AgentSerializer extends MyStdSerializer<Agent> {
		@Override
	    public void serialize(
	    		Agent value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			
			jgen.writeStartObject();
			HashMap<String, Object> map = ALJsonifier.agentToMap(value, true, null);
			for (String key : map.keySet()) {
				Object val = map.get(key);
				jgen.writeObjectField(key, val);
			}
			jgen.writeEndObject();
		}
	}
	
	public static class AgentListSerializer extends MyStdSerializer<AgentList> {
		@Override
	    public void serialize(
	    		AgentList value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartArray();
			for (int i = 0; i < value.size(); i++) {
				jgen.writeObject(value.get(i));
			}
			jgen.writeEndArray();
		}
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1678490259125</Id>
			<Name><![CDATA[SharedSuppressionMixIn]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.annotation.JsonIgnore;

public interface SharedSuppressionMixIn
{
	
	@JsonIgnore
    public Agent getActiveObject();
	
	@JsonIgnore
	public Agent getAgent();
	
	
	
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1678494803375</Id>
			<Name><![CDATA[PortSuppressionMixIn]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.annotation.JsonIgnore;

public interface PortSuppressionMixIn extends SharedSuppressionMixIn
{
	@JsonIgnore
	public String getName();
	
	@JsonIgnore
	public String getFullName();
	
	@JsonIgnore
	public FlowchartBlock getFlowchartBlockRepresentative();
	
	@JsonIgnore
	public FlowchartBlock getFlowchartBlockRepresentative(Agent agent);
	
	@JsonIgnore
	public List getStatechartLinks();
	
	@JsonIgnore
	public List getFlatLinks();
	
	@JsonIgnore
	public List getUpLinks();
	
	@JsonIgnore
	public List getDownLinks();
}]]></Text>
		</JavaClass>
	</JavaClasses>
	<Libraries>
		<!--   =========   Library   ========  -->
		<Library>
			<Id>1665789589643</Id>
			<Name><![CDATA[JSONifierLib]]></Name>
			<Description><![CDATA[A simple library for enabling AnyLogic objects to be JSON serializable. 
After creating an instance of it, use the provided "toJson" and "fromJson" functions.
It also includes a filter for some customization into what is included when calling "toJson".]]></Description>
			<AOCEntry>
				<ActiveObjectClassId>1665787765899</ActiveObjectClassId>
			</AOCEntry>

			<IconResourceReference>
				<PackageName><![CDATA[anylogic_jsonifier_library]]></PackageName>
				<ClassName><![CDATA[jsonifier_16.png]]></ClassName>
			</IconResourceReference>
			<VersionMajor>0</VersionMajor>
			<VersionMinor>1</VersionMinor>
			<VersionBuild>0</VersionBuild>
			<Provider><![CDATA[]]></Provider>    
		</Library>
	</Libraries>
	<ModelResources>
		<Resource>
			<Path><![CDATA[jsonifier_16.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
	</ModelResources>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.modules.markup_descriptors]]></LibraryName>
		<VersionMajor>1</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>0</VersionBuild>
    </RequiredLibraryReference>
</Model>
</AnyLogicWorkspace>